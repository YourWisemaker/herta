## Publishing to npm

This package is ready for npm publication. Follow these steps to publish:

1. **Verify Package Content**:
   ```bash
   npm pack
   ```
   This will create a `.tgz` file containing what would be published to npm. Inspect it to ensure it contains the correct files.

2. **Run Tests**:
   ```bash
   npm test
   npm run test:mocha  # Run Mocha tests for specialized modules
   ```
   
3. **Build Documentation**:
   ```bash
   npm run docs
   ```

4. **Publish to npm**:
   ```bash
   # For a first-time publication
   npm publish
   
   # For a new version
   npm version [patch|minor|major]
   npm publish
   ```

## Specialized Modules

Herta.js includes several specialized modules for advanced mathematical and scientific computing. Here are examples of some particularly powerful modules:

### Optimization Module

```javascript
// Classical optimization
const result = herta.optimization.gradientDescent({
  objective: (x) => Math.pow(x[0], 2) + Math.pow(x[1], 2),
  gradient: (x) => [2 * x[0], 2 * x[1]],
  initialParams: [10, 10],
  learningRate: 0.1,
  maxIterations: 100
});

// Metaheuristic optimization
const geneticResult = herta.optimization.geneticAlgorithm({
  fitnessFunction: (chromosome) => -Math.pow(chromosome[0], 2) - Math.pow(chromosome[1], 2),
  chromosomeLength: 2,
  populationSize: 50,
  generations: 100
});

// Linear programming with simplex method
const lpResult = herta.optimization.simplexMethod({
  objective: [3, 4], // Maximize 3x + 4y
  constraints: [
    [1, 2],  // x + 2y ≤ 14
    [3, -1], // 3x - y ≤ 0
    [1, -1]  // x - y ≤ 2
  ],
  rhs: [14, 0, 2],
  maximize: true
});
```

### Graph Theory Module

```javascript
const graph = herta.graph.createUndirectedGraph();

// Add vertices and edges
['A', 'B', 'C', 'D', 'E'].forEach(v => graph.addVertex(v));
graph.addEdge('A', 'B', { weight: 2 });
graph.addEdge('B', 'C', { weight: 1 });
graph.addEdge('C', 'D', { weight: 3 });
graph.addEdge('D', 'E', { weight: 1 });
graph.addEdge('A', 'E', { weight: 5 });

// Find shortest path
const path = herta.graph.shortestPath(graph, 'A', 'D');
console.log(path.vertices, path.distance);

// Find minimum spanning tree
const mst = herta.graph.minimumSpanningTree(graph, 'kruskal');

// Calculate centrality measures
const degreeCentrality = herta.graph.degreeCentrality(graph);
const betweennessCentrality = herta.graph.betweennessCentrality(graph);

// Detect communities
const communities = herta.graph.communityDetection(graph, 'louvain');
```

### Number Theory Module

```javascript
// Fast prime factorization
const factors = herta.numberTheory.primeFactorize(12345678);

// Extended Euclidean Algorithm
const { gcd, x, y } = herta.numberTheory.extendedGCD(123, 456);
// This gives Bézout coefficients x, y such that: x*123 + y*456 = gcd

// Chinese Remainder Theorem
const solution = herta.numberTheory.chineseRemainderTheorem([3, 4, 5], [5, 7, 9]);
// Finds x such that: x ≡ 3 (mod 5), x ≡ 4 (mod 7), x ≡ 5 (mod 9)

// Euler's Totient Function
const totient = herta.numberTheory.eulerTotient(60);

// Generate primitive Pythagorean triples
const triples = herta.numberTheory.primitivePythagoreanTriples(100);
```

### String Algorithms Module

```javascript
// Pattern matching algorithms
const text = "This is a test string for pattern matching";
const pattern = "pattern";

const kmpMatches = herta.stringAlgorithms.kmpSearch(text, pattern);
const boyerMooreMatches = herta.stringAlgorithms.boyerMooreSearch(text, pattern);
const rabinKarpMatches = herta.stringAlgorithms.rabinKarpSearch(text, pattern);

// String similarity and distance
const str1 = "kitten";
const str2 = "sitting";
const editDistance = herta.stringAlgorithms.levenshteinDistance(str1, str2);
const lcs = herta.stringAlgorithms.longestCommonSubsequence(str1, str2);
const similarity = herta.stringAlgorithms.stringSimilarity(str1, str2);

// Suffix arrays
const suffixArray = herta.stringAlgorithms.buildSuffixArray("banana");
const longestRepeated = herta.stringAlgorithms.longestRepeatedSubstring("banana");

// String compression
const compressed = herta.stringAlgorithms.runLengthEncode("aaabbbcccaaabbbaaabbbcccaaa");
```

### Quantum Mechanics Module

```javascript
// Create quantum states
const state = herta.quantum.createState([1/Math.sqrt(2), 1/Math.sqrt(2)]);

// Apply quantum gates
const xGateState = herta.quantum.applyGate('X', herta.quantum.createState([1, 0]));
const hadamardState = herta.quantum.applyGate('H', herta.quantum.createState([1, 0]));

// Apply custom rotation
const rotatedState = herta.quantum.applyRotation(
  herta.quantum.createState([1, 0]), 
  Math.PI/2, 
  [0, 0, 1]
);

// Tensor product of quantum states
const combinedState = herta.quantum.tensorProduct(
  herta.quantum.createState([1, 0]),
  herta.quantum.createState([0, 1])
);

// Quantum measurements and entropy
const bellState = herta.quantum.createState([1/Math.sqrt(2), 0, 0, 1/Math.sqrt(2)]);
const entropy = herta.quantum.vonNeumannEntropy(bellState);
```

### Computer Vision Module

```javascript
// Image processing fundamentals
const grayscale = herta.computerVision.rgbToGrayscale(image);
const blurred = herta.computerVision.gaussianBlur(grayscale, 5, 1.4);
const equalized = herta.computerVision.histogramEqualization(grayscale);

// Edge detection
const sobelEdges = herta.computerVision.sobelEdgeDetection(grayscale);
const cannyEdges = herta.computerVision.cannyEdgeDetection(grayscale, 30, 100);

// Feature detection and matching
const corners = herta.computerVision.fastCornerDetection(grayscale, 20, 0.8);
const keypoints = herta.computerVision.detectKeypoints(grayscale);
const descriptors = herta.computerVision.computeDescriptors(grayscale, keypoints);
const matches = herta.computerVision.matchFeatures(descriptors1, descriptors2, 0.7);

// Advanced algorithms
const circles = herta.computerVision.houghCircleDetection(grayscale, 10, 30);
const segments = herta.computerVision.kmeansSegmentation(image, 5);
```

### Probability Theory Module

```javascript
// Probability distributions
const binomialPmf = herta.probabilityTheory.binomial.pmf(10, 0.5, 6);
const binomialCdf = herta.probabilityTheory.binomial.cdf(10, 0.5, 6);
const poissonPmf = herta.probabilityTheory.poisson.pmf(3, 4);
const normalPdf = herta.probabilityTheory.normal.pdf(0, 1, 0.5);

// Random sampling
const normalSamples = herta.probabilityTheory.normal.sample(0, 1, 100);
const exponentialSamples = herta.probabilityTheory.exponential.sample(0.5, 50);

// Hypothesis testing
const tTestResult = herta.probabilityTheory.tTest(sample1, sample2);
console.log(`p-value: ${tTestResult.pValue}, t-statistic: ${tTestResult.tStat}`);

// Monte Carlo integration
const integral = herta.probabilityTheory.monteCarloIntegration(
  (x) => Math.sin(x) * Math.exp(-x*x/2), 
  0, Math.PI, 
  10000
);
```

### Fluid Dynamics Module

```javascript
// Basic fluid properties calculations
const reynoldsNumber = herta.fluidDynamics.reynoldsNumber({
  velocity: 2,     // m/s
  diameter: 0.05,  // m
  density: 1000,   // kg/m^3
  viscosity: 0.001 // Pa·s
});

// Calculate friction factor using Colebrook-White equation
const frictionFactor = herta.fluidDynamics.colebrookWhite({
  reynoldsNumber: 100000,
  relativeRoughness: 0.0001
});

// Calculate pressure drop in a pipe
const pressureDrop = herta.fluidDynamics.pressureDrop({
  frictionFactor: 0.02,
  length: 10,       // m
  diameter: 0.05,   // m
  density: 1000,    // kg/m^3
  velocity: 2       // m/s
});

// 1D fluid simulation
const simulation = herta.fluidDynamics.createAdvectionDiffusionSolver({
  length: 10,        // domain length
  nodes: 100,        // number of grid points
  diffusivity: 0.01, // diffusion coefficient
  velocity: 0.5      // advection velocity
});

// Run simulation for 100 time steps
const results = simulation.solve(initialCondition, 100);
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT
